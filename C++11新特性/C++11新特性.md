# C++11新特性

## 1.C++11让程序更简洁

### 1.1类型推导

C++11 中引入了类型推导（Type Deduction）机制，它可以帮助程序员减少显式指定变量类型的繁琐操作，使代码更加简洁和易于维护。C++11 类型推导主要包括以下几个方面：

#### 1.1.1 auto关键字

`auto` 用于根据初始化表达式自动推导变量的类型。

```c++
auto x = 42;          // 推导为 int
auto y = 3.14;        // 推导为 double
auto z = "hello";     // 推导为 const char*

std::vector<int> v{1, 2, 3};
auto it = v.begin();  // 推导为 std::vector<int>::iterator

const int a = 10;
auto b = a;         // b 的类型为 int（顶层 const 被忽略）

int x = 10;
int& ref = x;
auto y = ref;       // y 的类型为 int（不再是引用）
auto& z = ref;      // z 的类型为 int&（引用保留）
```

**必须初始化**：`auto` 声明的变量必须在定义时初始化，否则无法推导类型。

**顶层 `const` 被忽略**

**引用类型会被保留**

#### 1.1.2 `decltype` 关键字

`decltype` 用于获取表达式的类型，主要用于模板编程和需要明确类型的场景。

```c++
int x = 10;
decltype(x) y = 20;  // y 的类型是 int

std::vector<int> v{1, 2, 3};
decltype(v)::iterator it = v.begin();  // 类型为 std::vector<int>::iterator

const int a = 10;
decltype(a) b = 20;  // b 的类型为 const int

int x = 10;
int& ref = x;
decltype(ref) y = x; // y 的类型为 int&

```

与 `auto` 的区别:

* `decltype` 仅根据表达式确定类型，而 `auto` 则需要根据初始化的值。
* `decltype` 会保留顶层 `const` 和引用类型。

#### 1.1.3 `auto` 和 `decltype`结合

C++11 中，`decltype` 和 `auto` 可以结合使用，通常用于延迟推导或模板编程中：

```c++
auto x = 42;                   // x 的类型为 int
decltype(x) y = 3.14;          // y 的类型为 int，因为 x 的类型是 int

auto func = [](int a) { return a * 2; };
decltype(func) anotherFunc = func;  // anotherFunc 的类型与 func 相同
```

#### 1.1.4  **模板编程中的类型推导**

在模板函数中，类型推导可以自动根据传入参数的类型确定模板参数的类型：

```c++
template<typename T>
void printType(T value) {
    std::cout << typeid(T).name() << std::endl;
}

int main() {
    printType(42);       // 推导为 int
    printType(3.14);     // 推导为 double
    printType("hello");  // 推导为 const char*
}
```

#### 1.1.5 `auto` 和数组、指针的类型推导

```c+=
int arr[] = {1, 2, 3};
auto p = arr;         // p 的类型为 int*，数组退化为指针
decltype(arr) q = arr; // q 的类型为 int[3]，保留数组类型

int add(int a, int b) { return a + b; }

auto func = add;           // func 的类型为 int(*)(int, int)
decltype(add) anotherFunc; // anotherFunc 的类型为 int(int, int)

```

#### 1.1.6  **常见应用场景**

- **简化代码**：无需显式写出复杂类型，尤其在模板编程或 STL 中。
- **函数返回类型推导**
- **模板元编程**：在泛型代码中自动推导类型，减少冗余。

```c++
std::map<std::string, std::vector<int>> myMap;
auto it = myMap.begin();  // 代替 std::map<std::string, std::vector<int>>::iterator

auto add = [](int a, int b) { return a + b; };  // 自动推导返回类型为 int
```

通过 `auto` 和 `decltype`，C++11 提供了更强大的类型推导功能，既可以让代码更加简洁，又能保留类型安全性，是现代 C++ 编程的重要特性之一。

### 1.2 模板的细节与改进

#### 1.2.1 `constexpr` 模板

C++11 引入了 `constexpr`，允许在编译时求值的常量表达式中使用模板。这使得模板元编程更加高效。

```c++
template<typename T>
constexpr T square(T x) {
    return x * x;
}

constexpr int result = square(5);  // 在编译时计算
```

#### 1.2.2  **变参模板（Variadic Templates）**

C++11 引入了变参模板，使模板可以接收任意数量的模板参数。

```c++
template<typename... Args>
void printAll(Args... args) {
    (std::cout << ... << args) << std::endl;  // 使用 C++17 的折叠表达式
}

int main() {
    printAll(1, "hello", 3.14);
}
```

特性：

- 使用 `sizeof...(Args)` 可以获取模板参数的数量。
- 通过递归展开参数包处理各个参数：

```c++
template<typename T, typename... Args>
void print(T first, Args... rest) {
    std::cout << first << " ";
    print(rest...);  // 递归调用
}

void print() {}  // 基础情况
```

#### 1.2.3 别名模板（Alias Templates）

C++11 引入了 `using` 关键字，可以定义模板别名，作为 `typedef` 的替代，更加灵活。

```c++
template<typename T>
using Vec = std::vector<T>;

Vec<int> v = {1, 2, 3};  // 等价于 std::vector<int>
```

### 1.3 列表初始化

c++11 中引入了**列表初始化**（List Initialization），也称为统一初始化（Uniform Initialization），是一种更现代、更安全的变量初始化方式。它使用大括号 `{}` 语法来初始化变量，适用于各种类型，包括基本数据类型、数组、类和容器等。

#### 1.3.1 基本语法

```c++
int x{42};  // 列表初始化，等价于 int x = 42;

int a{10};       // 初始化为 10
double b{3.14};  // 初始化为 3.14
char c{'A'};     // 初始化为 'A'
int arr[5]{1, 2, 3};  // 前 3 个元素初始化为 1, 2, 3，其他初始化为 0

struct Point {
    int x;
    int y;
};
Point p{1, 2};  // 初始化为 x=1, y=2

#include <vector>
std::vector<int> vec{1, 2, 3, 4};  // 初始化为包含 1, 2, 3, 4 的 vector

int x{};         // 初始化为 0
double y{};      // 初始化为 0.0
std::string s{}; // 初始化为空字符串

class MyClass {
public:
    MyClass(int x, int y) : a(x), b(y) {}
private:
    int a;
    int b;
};
MyClass obj{10, 20};  // 调用 MyClass(int, int) 构造函数
```

#### 1.3.2 防止窄化转换

列表初始化能够防止由窄化转换引起的潜在错误（如从 `double` 转为 `int`，或从 `long` 转为 `float`）。

```c+=
int a{3.14};  // 错误！窄化转换不允许
int b = 3.14; // 合法，但会丢失精度，b 的值为 3

```

窄化转换检测的特性使得列表初始化更加安全。

#### 1.3.3 与 `std::initializer_list` 的结合

C++11 引入了 `std::initializer_list` 类型，允许构造函数接受一个参数包形式的列表。

```c++
#include <initializer_list>
#include <iostream>
#include <vector>

class MyClass {
public:
    MyClass(std::initializer_list<int> values) {
        for (int value : values) {
            std::cout << value << " ";
        }
        std::cout << std::endl;
    }
};

MyClass obj{1, 2, 3, 4};  // 输出: 1 2 3 4
```

标准容器（如 `std::vector`）也支持 `initializer_list`：

```c++
std::vector<int> vec{1, 2, 3, 4};  // 通过 std::initializer_list 初始化
```

#### 1.3.4 限制和注意事项

列表初始化与构造函数的歧义

当类既定义了接受 `std::initializer_list` 的构造函数，又有其他重载构造函数时，可能会产生歧义：

```c++
#include <iostream>

class MyClass {
public:
    MyClass(int x, int y) {
        std::cout << "Normal constructor" << std::endl;
    }
    MyClass(std::initializer_list<int> values) {
        std::cout << "Initializer_list constructor" << std::endl;
    }
};

int main() {
    MyClass obj1{10, 20};  // 调用 initializer_list 构造函数
    MyClass obj2(10, 20);  // 调用普通构造函数
}
```

列表初始化无法与动态分配结合

```c++
int* ptr = new int{10};  // 合法
int* arr = new int[3]{1, 2, 3};  // 错误！动态数组不支持列表初始化
```

#### 1.3.5 列表初始化的优点

**安全性高**：防止窄化转换和未初始化的变量。

**简洁性**：统一了不同类型的初始化方式。

**兼容性好**：支持自定义类型与容器的初始化。

C++11 的列表初始化不仅提高了代码的安全性和可读性，还为未来的标准（如 C++14 和 C++17）奠定了基础。

### 1.4 基于范围的for循环

C++11 引入了基于范围的 `for` 循环（range-based for loop），极大简化了遍历容器或数组的代码，同时提高了可读性和代码安全性。它是传统 `for` 循环的一种简洁替代。

```c++
int arr[] = {1, 2, 3, 4, 5};
for (int x : arr) {
        std::cout << x << " ";  // 输出: 1 2 3 4 5
    }
```

#### 1.4.1 引用与值的区别

按值遍历

- 默认情况下，基于范围的 `for` 循环是按值遍历的，每次循环会创建一个元素的副本。
- 修改循环变量不会影响原始数据。

```c++
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {10, 20, 30, 40};

    for (int x : vec) {
        x += 5;  // 修改 x 不会影响 vec
    }

    for (int x : vec) {
        std::cout << x << " ";  // 输出: 10 20 30 40
    }

    return 0;
}
```



按引用遍历

- 使用 `&` 可以按引用遍历，直接操作原始数据。
- 适用于需要修改容器内容的场景。

```c++
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {10, 20, 30, 40};

    for (int& x : vec) {
        x += 5;  // 修改 vec 中的元素
    }

    for (int x : vec) {
        std::cout << x << " ";  // 输出: 15 25 35 45
    }

    return 0;
}
```

使用 `const` 引用

- 如果只需要读取数据且不希望拷贝，可以使用 `const &`，既避免了拷贝，又保护了原数据。

```c++
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {10, 20, 30, 40};

    for (const int& x : vec) {
        std::cout << x << " ";  // 输出: 10 20 30 40
    }

    return 0;
}
```

#### 1.4.2 **适用范围**

基于范围的 `for` 循环适用于：

1. **数组**
2. **标准容器**（如 `std::vector`、`std::list`、`std::map` 等）
3. **`std::initializer_list`**
4. **用户定义的类型**（实现了 `begin()` 和 `end()` 成员函数，或非成员函数）

### 1.5 std::function 和 bind 绑定器

#### 1.5.1 可调用对象包装器——std::function

`std::function` 是一个通用的**函数包装器**，它可以存储可调用对象（如普通函数、Lambda 表达式、函数指针、函数对象等）。

```c++
#include <functional>

// 通用形式
std::function<ReturnType(Arg1Type, Arg2Type, ...)> func;
```

1. 存储普通函数

```C++
#include <iostream>
#include <functional>

void printMessage(const std::string& message) {
    std::cout << message << std::endl;
}

int main() {
    std::function<void(const std::string&)> func = printMessage;
    func("Hello, std::function!");  // 输出: Hello, std::function!
    return 0;
}
```

2. 存储 Lambda 表达式

```c++
#include <iostream>
#include <functional>

int main() {
    std::function<int(int, int)> add = [](int a, int b) { return a + b; };
    std::cout << add(3, 4) << std::endl;  // 输出: 7
    return 0;
}
```



2. 存储函数对象

```c++
#include <iostream>
#include <functional>

struct Multiply {
    int operator()(int a, int b) const {
        return a * b;
    }
};

int main() {
    std::function<int(int, int)> multiply = Multiply();
    std::cout << multiply(3, 4) << std::endl;  // 输出: 12
    return 0;
}
```

#### 1.5.2 std::bind邦定器

`std::bind` 是一个函数适配器，用于创建新的函数对象，可以绑定函数的部分或全部参数，从而生成一个新的可调用对象。绑定对象结果可以使用std::function进行保存，并延迟调用在我们需要的时候。

```c++
#include <functional>

// 通用形式
std::bind(Callable, Arg1, Arg2, ...);

Callable：可以是普通函数、Lambda 表达式、函数指针、成员函数等。
Arg1, Arg2, ...：参数列表，可以绑定特定值，也可以使用占位符（std::placeholders::_1 等）表示延迟传递的参数。
```

1.绑定普通函数

```c++
#include <iostream>
#include <functional>

int add(int a, int b) {
    return a + b;
}

int main() {
    auto add_five = std::bind(add, std::placeholders::_1, 5);
    std::cout << add_five(3) << std::endl;  // 输出: 8
    return 0;
}
```

2.绑定成员函数

```c++
#include <iostream>
#include <functional>

class Printer {
public:
    void print(const std::string& message) {
        std::cout << message << std::endl;
    }
};

int main() {
    Printer printer;
    auto boundPrint = std::bind(&Printer::print, &printer, std::placeholders::_1);
    boundPrint("Hello from Printer!");  // 输出: Hello from Printer!
    return 0;
}
```

#### 1.5.3 `std::function` 和 `std::bind` 的结合

* 可以用 `std::bind` 生成可调用对象，并将其存储到 `std::function` 中。

```c++
#include <iostream>
#include <functional>

int multiply(int a, int b) {
    return a * b;
}

int main() {
    std::function<int(int)> multiply_by_two = std::bind(multiply, 2, std::placeholders::_1);
    std::cout << multiply_by_two(5) << std::endl;  // 输出: 10
    return 0;
}
```

* 在很多情况下，`std::bind` 的功能可以被 Lambda 表达式替代，且 Lambda 表达式更直观和灵活。

* C++11 中的 `std::function` 和 `std::bind` 提供了强大的函数封装和绑定功能，在现代 C++ 编程中非常重要，尤其是在回调、异步操作和函数式编程中。

### 1.6 lambda表达式

C++11 引入的 **Lambda 表达式** 是一种轻量级的匿名函数，可以直接在代码中定义并使用，非常适合需要临时函数或作为回调函数的场景。Lambda 表达式在现代 C++ 编程中非常重要，简化了代码，提高了可读性和灵活性。

#### 1.6.1 Lambda 表达式的基本语法

```c++
[捕获列表](参数列表) -> 返回类型 {
    // 函数体
};
捕获列表：指定 Lambda 如何捕获外部变量。
参数列表：定义传递给 Lambda 的参数（可省略）。
返回类型：可选，指定返回类型（若能推导，可省略）。
函数体：Lambda 的具体实现逻辑。
```

#### 1.6.2 捕获列表

* [] 不捕获任何变量
* [&] 按引用捕获所有外部变量，可读可改。
*  [x]仅按值捕获变量 `x`，无法修改 `x`。
* [&x]仅按引用捕获变量 `x`，可以修改 `x`。
* [=, &x]按值捕获所有变量，但 `x` 按引用捕获。
* [&, x]按引用捕获所有变量，但 `x` 按值捕获。

## 2. 使用C++11改进程序性能

### 2.1 右值引用

#### 2.1.1 &&的特性

在 C++ 中，表达式的值可以分为 **左值** 和 **右值**。右值通常是临时对象或即将被销毁的对象。

- **左值（lvalue）** 是指可以取地址的对象（即存在于内存中的对象，生命周期较长）。
- **右值（rvalue）** 是指无法取地址的临时对象，通常是某些表达式的结果（例如，字面量、运算结果等）。右值的生命周期非常短，通常只在一个表达式中存在。

`&&` 用于标记右值引用，它使得程序可以更加高效地处理临时对象，特别是在移动语义和完美转发等方面。

`&&` 的总结如下：

```markdown
1) 左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。
2）auto&& 或函数参数类型自动推导的T&& 是一个未定义的引用类型，被称为universal references, 它可能是左值也可能是右值引用类型，取决于初始化值得类型。
3）所有得右值引用叠加到右值引用上任然是一个右值引用，而输入右值时则变为具名的右值引用。
4）编译器会将已命名的右值引用视为左值，而将未命名的右值引用视为右值
```

#### 2.1.2 右值优化性能避免深拷贝

右值引用的一个重要用途是**移动语义**，它使得对象可以被“移动”而不是被拷贝，从而避免不必要的拷贝操作，提高性能。

- 移动语义通过将资源从一个对象转移到另一个对象来避免昂贵的深拷贝操作。
- 只有当对象是右值时，才能进行移动操作（右值代表的是即将销毁的临时对象，可以安全地转移资源）。

C++ 引入了 **移动语义**，即在对象生命周期的某些时刻，可以“移动”对象的资源（如动态分配的内存、文件句柄等），而不是做不必要的深拷贝。

移动语义可以将资源（堆、系统对象等）通过浅拷贝方式从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，可以大幅度提高C++应用程序的性能，消除临时对象的维护（创建和销毁）对性能的影响。

例如，标准库容器（如 `std::vector`）在使用移动语义时，可以避免不必要的内存拷贝：

```c++
#include <vector>
#include <iostream>

class MyClass {
public:
    MyClass() { std::cout << "Constructor\n"; }
    MyClass(const MyClass&) { std::cout << "Copy constructor\n"; }
    MyClass(MyClass&&) noexcept { std::cout << "Move constructor\n"; }
};

int main() {
    std::vector<MyClass> v;
    v.push_back(MyClass());  // Move constructor is used here
}
// MyClass() 是一个右值，它会触发 Move constructor，而不是 Copy constructor，从而提高效率
```

移动赋值（Move Assignment）右值引用还可用于定义**移动赋值运算符**，允许将一个临时对象的资源移动到已有对象中。

```c++
class MyClass {
public:
    MyClass& operator=(MyClass&& other) noexcept {
        if (this != &other) {
            // Move the resources from 'other' to 'this'
        }
        return *this;
    }
};
// 在移动赋值中，MyClass&& 表示右值引用，表示可以将资源从一个临时对象（右值）转移到当前对象
```

### 2.2 Move()语义

`std::move` 主要的作用是 **将左值转换为右值引用**，从而允许在需要时移动对象的资源。它本身并不移动数据，而是**将对象标记为可以被移动的右值**，使得编译器能够选择调用移动构造函数或移动赋值运算符。

```c++
T&& std::move(T& x); // 将左值 x 转换为右值引用
```

为了更高效地管理资源，C++ 引入了 **移动语义**，即在对象生命周期的某些时刻，可以“移动”对象的资源（如动态分配的内存、文件句柄等），而不是做不必要的深拷贝。移动语义需要配合右值引用和 `std::move` 使用。

**右值引用**（通过 `T&&` 标记）指示某个对象是“临时的”，生命周期短暂的，可以通过**移动**而不是拷贝来节省资源和时间。

**移动构造函数**

移动构造函数是使用 `std::move` 的一个典型场景。它允许将一个对象的资源从一个临时对象转移到一个新的对象中。

**移动赋值运算符**

移动赋值运算符通常与 `std::move` 一起使用，在赋值时避免不必要的拷贝。

```c++
#include <iostream>
#include <vector>

class MyClass {
public:
    MyClass(int size) : data(size) {
        std::cout << "Constructor\n";
    }
    MyClass(MyClass&& other) noexcept : data(std::move(other.data)) {
        std::cout << "Move constructor\n";
    }

    MyClass& operator=(MyClass&& other) noexcept {
        if (this != &other) {
            data = std::move(other.data);  // Move assignment
        }
        return *this;
    }

private:
    std::vector<int> data;
};

int main() {
    MyClass a(10);
    MyClass b = std::move(a);  // Calls move constructor
}
// std::move(a) 将 a 转换为右值引用，从而使得 b 可以通过 移动赋值运算符 更新其内容。
```

**总结**

* `std::move` 是一个用于将对象标记为右值引用的函数。
* 它与 **右值引用** 一起使用，允许通过 **移动构造函数** 或 **移动赋值运算符** 来避免不必要的拷贝，提高性能。
* `std::move` 不会实际移动对象，而只是使得对象变为右值，允许编译器选择使用移动语义。
* 使用 `std::move` 后，原对象的状态变得不确定，不能再安全地使用。

### 2.3 forward 和完美转发

`std::forward` 是 C++11 引入的一个标准库函数，它与 **完美转发（Perfect Forwarding）** 密切相关。完美转发是一个技术，旨在将传递给函数的参数 **完美地** 转发给另一个函数，同时保持它们的值类别（即左值或右值）。

完美转发的目标是在函数模板中传递参数时，不丢失参数的值类别（是否为左值或右值）。在 C++ 中，**左值** 是可以被取地址的对象，而**右值** 是临时对象或即将销毁的对象。完美转发能够确保将一个左值传递给另一个函数时仍然是左值，将右值传递时仍然是右值。

C++ 中有很多场景需要完美转发，例如，在 **函数包装器**、**工厂函数** 和 **模板库** 中。完美转发让你能够准确地传递给目标函数，而不需要自己判断是左值还是右值。

`std::forward` 用于 **完美转发**，其主要功能是根据传入的参数类型 **保留** 原始参数的值类别。

```C++
template <typename T>
T&& forward(std::remove_reference_t<T>&& t) noexcept;
// std::forward<T>(t) 会根据 T 是否为左值类型或右值类型来决定是否转发为左值或右值引用。
// 通过 std::forward<T>，你可以保证正确地转发传递给模板函数的参数，同时保持其原始值类别。
```

`std::forward` 通常与 **右值引用**（`T&&`）结合使用，特别是在函数模板中。它的关键作用是将右值引用的参数完美转发到其他函数中，保持其值类别（左值或右值）不变。

**示例：完美转发的典型场景**

假设你有一个函数 `wrapper`，它接收一个通用的参数，并将这个参数传递给另一个函数。

```C++
#include <iostream>
#include <utility>  // For std::forward

void print(int& x) {
    std::cout << "Lvalue: " << x << std::endl;
}

void print(int&& x) {
    std::cout << "Rvalue: " << x << std::endl;
}

template <typename T>
void wrapper(T&& arg) {
    print(std::forward<T>(arg));  // 完美转发
}

int main() {
    int a = 10;
    wrapper(a);         // Lvalue 转发
    wrapper(20);        // Rvalue 转发
}
```

#### `std::forward` vs `std::move`

- `std::move` 强制将一个对象转换为右值引用，而 `std::forward` 只是根据实际的传递参数类型来转发。
- `std::move` 是将一个对象标记为右值引用，使其可以被移动，通常用在需要转移资源的地方。
- `std::forward` 用于转发一个参数时，保持其值类别（左值或右值），通常出现在模板函数中。

**总结**

* **完美转发** 是指传递函数的参数时，确保参数的值类别（左值或右值）保持不变。
* `std::forward` 是实现完美转发的关键函数，它能够根据模板类型决定是否转发为右值引用或左值引用。
* `std::move` 和 `std::forward` 具有不同的目的：`std::move` 用于将对象标记为右值，而 `std::forward` 用于根据类型转发对象，保持其原始值类别。

### 2.4 `emplace_back`减少内存拷贝和移动

在 C++ 中，`emplace_back` 是 `std::vector`（以及其他标准容器如 `std::deque` 和 `std::list`）提供的一个非常有用的成员函数，它可以 **减少内存拷贝和移动**，从而提高性能。为了理解这一点，我们需要比较 `emplace_back` 与 `push_back` 的工作方式。

#### 2.4.1 `push_back` 和 `emplace_back` 的区别

`push_back`：

* `push_back` 将一个对象拷贝（或移动）到容器中。
* 如果你调用 `push_back` 并传入一个对象（如 `obj`），那么该对象会被 **拷贝** 或 **移动** 到容器中。

```c++
std::vector<int> vec;
int num = 10;
vec.push_back(num);  // 需要拷贝 num 进容器

vec.push_back(20);   // 直接移动 20 到容器
```

emplace_back：

* `emplace_back` 直接在容器中 **构造** 对象，避免了拷贝或移动操作。
* 它接受参数并在容器的末尾**原地构造**该对象，而不是将已有对象拷贝或移动到容器中。

```c++
std::vector<int> vec;
int num = 10;
vec.emplace_back(num);  // 在容器末尾原地构造 num

vec.emplace_back(20);   // 直接构造 20
```

#### 2.4.2 为什么 `emplace_back` 可以减少内存拷贝和移动

##### 2.4.2.1  原地构造对象

`emplace_back` 通过原地构造对象来避免拷贝和移动。当我们使用 `push_back` 时，如果传递给容器的对象是一个具名对象（比如 `int num`），那么容器需要将该对象 **拷贝或移动** 到容器的内部存储区。而 `emplace_back` 会直接在容器内部的内存空间中 **构造** 该对象，这意味着：

- 如果对象是一个临时对象（右值），则可以直接在容器内构造该对象，避免了拷贝。
- 如果对象是一个具名对象（左值），则直接在容器内构造该对象，避免了拷贝。

##### 2.4.2.2 移动和拷贝的成本

在使用 `push_back` 时，当传递的对象是一个具名对象（左值）时，会涉及到一次拷贝构造或移动构造。这些构造操作的成本取决于对象的大小、复杂度和资源管理（例如，内存分配）。

相比之下，`emplace_back` 会避免这些成本，因为它直接在容器的内部内存位置构造对象，因此不会产生不必要的拷贝或移动。

##### 2.4.2.3 内存管理

`emplace_back` 也有一个额外的优势：它可以直接在容器的底层内存中构造对象，而无需进行额外的内存分配和复制操作。容器只需要在末尾分配足够的空间，直接构造新的元素，而不需要为每个元素创建一个新的副本。

##### 2.4.2.4  何时使用 `emplace_back` 而非 `push_back`

**对象构造的性能要求较高时**：如果对象的构造较为复杂，或者对象管理的资源较大，使用 `emplace_back` 可以避免不必要的拷贝，提升性能。

**传递右值时**：如果你传递一个临时对象（右值），`emplace_back` 会避免额外的拷贝。

**避免不必要的拷贝**：如果传递的是具名对象（左值），`emplace_back` 仍然会直接在容器内构造对象，避免了拷贝。

#### 2.3.3 总结

* `push_back` 会将一个已有对象拷贝或移动到容器中。

* `emplace_back` 直接在容器中构造一个对象，避免了额外的拷贝或移动，能够提供更好的性能，尤其是对于较为复杂的对象。
* 在大多数情况下，`emplace_back` 会优于 `push_back`，特别是当你需要传递一个构造函数参数来创建一个对象时，`emplace_back` 直接在容器中构造对象，避免了拷贝和移动。

### 2.5 `unordered container` 无序容器

`C++11` 增加了无序容器 std::unordered_map`、`std::unordered_set`、`std::unordered_multimap` 和 `std::unordered_multiset， 由于这些容器中的元素是不排序的，因此，比有序容器`map/multimap `和`set/multiset`效率更高。`map`和`set`内部是红黑树，在插入元素时会自动排序，而无序容器内部是散列表（`Hash Table`），通过哈希，而不是排序来快速操作元素，使得效率更高。由于无序容器内部是散列表，因此无需容器的`key`需要提供`hash_value`函数，其他用法和`map/set`的用法是一样的。不过对于自定义的`key`，需要提供`Hash`函数和比较函数。

```c++
#include <iostream>
#include <unordered_map>

struct MyClass {
    int a, b;
    // 通常需要自定义比较函数来判断两个元素是否相等（这通常通过 operator== 完成）
    bool operator==(const MyClass& other) const {
        return a == other.a && b == other.b;
    }
};

// 自定义哈希函数
struct MyClassHash {
    std::size_t operator()(const MyClass& obj) const {
        return std::hash<int>()(obj.a) ^ std::hash<int>()(obj.b);
    }
};

int main() {
    std::unordered_map<MyClass, int, MyClassHash> umap;

    MyClass obj1 = {1, 2};
    MyClass obj2 = {3, 4};

    // 插入元素
    umap[obj1] = 10;
    umap[obj2] = 20;

    // 查找元素
    std::cout << "obj1: " << umap[obj1] << std::endl;  // 输出: obj1: 10
    std::cout << "obj2: " << umap[obj2] << std::endl;  // 输出: obj2: 20

    return 0;
}
```

## 3. 使用`C++11`解决内存泄漏的问题

只能指针是存储指向动态分配（堆）对象指针的类，用于生存期控制，能够确保在离开指针所在作用域时，自动正确的销毁动态分配的对象，防止内存泄漏。它的一种通用实现是使用引用计数。没使用一次，内部计数加一，析构一次，内部计数减一，减为0时，删除指向的堆内存。

C++11引入了三种类型的智能指针，它们能够自动管理动态分配的内存，并确保在不再需要该内存时正确地释放。使用时需要引入头文件`<memory>`。

### 3.1 `shared_ptr` 共享的智能指针

`std::shared_ptr` 是C++11引入的一个智能指针，属于“共享拥有”类型的智能指针，它允许多个指针实例共享对同一资源的所有权。`shared_ptr` 通过引用计数（reference counting）机制管理资源的生命周期，确保在最后一个指向该资源的 `shared_ptr` 被销毁时，资源会被自动释放。

**`std::shared_ptr` 的基本特性**

* **共享所有权**：多个 `shared_ptr` 实例可以共享同一个资源。引用计数保证资源在多个指针共享时不会提前被销毁。
* **引用计数**：每个 `shared_ptr` 都维护一个引用计数，记录当前有多少个 `shared_ptr` 指向同一个资源。当引用计数归零时，资源会被自动释放。
* **自动释放资源**：`shared_ptr` 会在最后一个指向资源的指针被销毁时自动释放资源，避免了内存泄漏。
* **线程安全**：`shared_ptr` 的引用计数的更新是线程安全的，可以在多线程环境中使用。

**`std::shared_ptr` 的用法**

**创建 `std::shared_ptr`**：`std::shared_ptr` 可以通过多种方式创建，最常见的方式是使用 `std::make_shared`，它可以避免直接使用 `new` 和 `delete` 关键字，并且更高效，因为它将资源和控制块（引用计数等）一次性分配。

```c++
#include <iostream>
#include <memory>

class Test {
public:
    Test() { std::cout << "Test constructed\n"; }
    ~Test() { std::cout << "Test destructed\n"; }
};

int main() {
    // 使用 std::make_shared 创建 shared_ptr
    std::shared_ptr<Test> ptr1 = std::make_shared<Test>();

    // 使用普通的构造函数创建 shared_ptr
    std::shared_ptr<Test> ptr2(new Test());

    return 0;
}
// std::make_shared 比直接使用 new 更高效，因为它一次性分配内存，而不是分两次分配（一次给对象，一次给控制块）。
// std::make_shared 避免了手动使用 delete，更安全。
```

**引用计数机制** ：每个 `shared_ptr` 都有一个引用计数，这个计数会随着指向该资源的 `shared_ptr` 数量的变化而增加或减少。每当一个 `shared_ptr` 被复制（拷贝构造）或赋值时，引用计数会增加。当一个 `shared_ptr` 被销毁时，引用计数会减少。如果引用计数降为零，资源会被释放。

```c++
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(10);
    std::cout << "ptr1 use count: " << ptr1.use_count() << std::endl; // 输出: 1

    std::shared_ptr<int> ptr2 = ptr1; // 复制构造
    std::cout << "ptr1 use count: " << ptr1.use_count() << std::endl; // 输出: 2

    std::shared_ptr<int> ptr3 = ptr2; // 继续复制
    std::cout << "ptr1 use count: " << ptr1.use_count() << std::endl; // 输出: 3

    ptr1.reset(); // ptr1 不再指向对象
    std::cout << "ptr2 use count: " << ptr2.use_count() << std::endl; // 输出: 2

    ptr2.reset(); // ptr2 不再指向对象
    std::cout << "ptr3 use count: " << ptr3.use_count() << std::endl; // 输出: 1

    return 0;
}
// ptr1 初始化时引用计数为1。
// ptr2 和 ptr3 拷贝了 ptr1，每次拷贝都增加引用计数。
// 当 ptr1 被重置（reset()）时，引用计数减少，但 ptr2 和 ptr3 依然保有资源，因此它们的引用计数保持不变。
```

**`std::shared_ptr` 的生命周期**：`std::shared_ptr` 的生命周期与所管理的对象紧密绑定。当 `shared_ptr` 离开作用域时，它会自动调用析构函数释放资源。如果一个 `shared_ptr` 是一个指向某个资源的最后一个实例，它将自动删除该资源。

```c++
#include <iostream>
#include <memory>

class Resource {
public:
    Resource() { std::cout << "Resource acquired.\n"; }
    ~Resource() { std::cout << "Resource released.\n"; }
};

int main() {
    {
        std::shared_ptr<Resource> ptr1 = std::make_shared<Resource>();  // 资源被申请
        std::shared_ptr<Resource> ptr2 = ptr1;  // ptr2 和 ptr1 共享资源
    }  // ptr1 和 ptr2 离开作用域，资源会被释放
    return 0;
}
// 当 ptr1 和 ptr2 离开作用域时，shared_ptr 自动释放资源，避免了内存泄漏
```

**使用`std::shared_ptr`需要注意的问题**

* 不要使用一个原始指针初始化多个`std::shared_ptr`。
* 不要在函数实参中创建`std::shared_ptr`。
* 通过`shared_from_this`返回`this`指针。
* 要避免循环引用。

**循环引用问题**：如果多个 `shared_ptr` 之间相互引用，那么引用计数将无法归零，从而导致资源无法释放，这是一个典型的循环引用问题。为了解决这个问题，`std::weak_ptr` 可以用来打破这种循环引用。

```c++
#include <iostream>
#include <memory>

class A;

class B {
public:
    std::shared_ptr<A> a_ptr;
    B() { std::cout << "B constructed\n"; }
    ~B() { std::cout << "B destructed\n"; }
};

class A {
public:
    std::shared_ptr<B> b_ptr;
    A() { std::cout << "A constructed\n"; }
    ~A() { std::cout << "A destructed\n"; }
};

int main() {
    std::shared_ptr<A> a = std::make_shared<A>();
    std::shared_ptr<B> b = std::make_shared<B>();
    
    a->b_ptr = b;
    b->a_ptr = a;

    return 0;
}
// a_ptr 和 b_ptr 互相持有对方的 shared_ptr，导致它们的引用计数永远不为零，从而内存无法释放。
```

**解决方案**：使用 `std::weak_ptr`：`std::weak_ptr` 不会增加引用计数，因此可以用来打破循环引用。它不会阻止对象的销毁，只是提供对对象的观察。

```c++
#include <iostream>
#include <memory>

class A;

class B {
public:
    std::weak_ptr<A> a_ptr;  // 使用 weak_ptr 打破循环引用
    B() { std::cout << "B constructed\n"; }
    ~B() { std::cout << "B destructed\n"; }
};

class A {
public:
    std::shared_ptr<B> b_ptr;
    A() { std::cout << "A constructed\n"; }
    ~A() { std::cout << "A destructed\n"; }
};

int main() {
    std::shared_ptr<A> a = std::make_shared<A>();
    std::shared_ptr<B> b = std::make_shared<B>();
    
    a->b_ptr = b;
    b->a_ptr = a;  // a_ptr 是 weak_ptr，不会增加引用计数

    return 0;
}
/*
A constructed
B constructed
A destructed
B destructed
*/
//通过使用 weak_ptr，我们可以打破循环引用问题，确保资源能够被正确释放。
```

**`std::shared_ptr` 的优缺点**

**优点**：

* 自动管理资源：通过引用计数自动管理内存，避免了手动调用 `delete`，减少了内存泄漏的风险。
* 支持多个所有者：多个 `shared_ptr` 可以共享同一资源，当最后一个 `shared_ptr` 被销毁时，资源会自动释放。
* 安全且方便：智能指针的使用使得程序更加安全且易于理解，减少了错误的发生。

**缺点**：

* 引用计数开销：每个 `shared_ptr` 都需要维护一个引用计数，可能会带来性能开销，尤其是在频繁创建、销毁的情况下。
* 循环引用问题：如果多个 `shared_ptr` 互相引用，会导致循环引用问题，造成内存泄漏。这个问题可以通过 `weak_ptr` 来解决。
* 性能损失：由于引用计数需要进行原子操作，因此在多线程环境下，`shared_ptr` 的性能可能受到影响。

`std::shared_ptr` 是C++11中非常强大的智能指针，它通过引用计数来共享资源的所有权，并且在所有者数量为零时自动释放资源。通过使用 `std::make_shared` 和 `std::weak_ptr`，可以有效地避免内存泄漏和循环引用问题，是现代C++中管理动态内存的首选方式。

### 3.2 `unique_ptr`独占的智能指针

`std::unique_ptr` 是 C++11 引入的一个智能指针，属于“独占拥有”类型的智能指针。它表示对资源的唯一拥有权，确保在任何时刻只有一个 `unique_ptr` 指向某个资源。当 `unique_ptr` 被销毁时，它所管理的资源会被自动释放。因此，它非常适合用于管理动态分配的内存或其他需要自动清理的资源。

**`std::unique_ptr` 的基本特性**

* **独占所有权**：每个 `unique_ptr` 都拥有它所指向的资源的唯一所有权。一个 `unique_ptr` 不允许被复制给另一个 `unique_ptr`，只能被移动。

* **自动释放资源**：当 `unique_ptr` 超出作用域时，它会自动调用资源的析构函数来释放资源，避免了内存泄漏。

* **不支持复制**：与 `shared_ptr` 不同，`unique_ptr` 不允许拷贝构造或拷贝赋值。它只能通过移动语义来转移所有权。

* **轻量级**：`unique_ptr` 具有很低的开销，因为它没有引用计数等机制，仅通过析构函数来管理资源。

**`std::unique_ptr` 的用法**

**创建 `std::unique_ptr`**：`std::unique_ptr` 的创建通常使用 `std::make_unique`，这是推荐的方式。它不仅避免了手动使用 `new` 和 `delete`，还避免了在调用 `new` 时可能发生的内存泄漏问题。

```c++
#include <iostream>
#include <memory>

class Test {
public:
    Test() { std::cout << "Test constructed\n"; }
    ~Test() { std::cout << "Test destructed\n"; }
};

int main() {
    // 使用 std::make_unique 创建 unique_ptr
    std::unique_ptr<Test> ptr = std::make_unique<Test>();
    return 0;
}
// 推荐使用 std::make_unique，而不是直接使用 new 来创建 unique_ptr。这样不仅更加简洁，还能避免不必要的内存分配错误。
```

**移动 `unique_ptr`**：`unique_ptr` 不支持复制操作，但它支持移动操作。通过 `std::move`，可以将一个 `unique_ptr` 的所有权从一个指针转移到另一个指针。这种转移是一次性的，即转移后原 `unique_ptr` 不再拥有资源。

```c++
#include <iostream>
#include <memory>

class Test {
public:
    Test() { std::cout << "Test constructed\n"; }
    ~Test() { std::cout << "Test destructed\n"; }
};

int main() {
    std::unique_ptr<Test> ptr1 = std::make_unique<Test>();
    
    // 转移所有权
    std::unique_ptr<Test> ptr2 = std::move(ptr1);
    
    // ptr1 现在为空，不能再使用
    if (!ptr1) {
        std::cout << "ptr1 is empty\n";
    }

    return 0;
}
/*
Test constructed
ptr1 is empty
Test destructed
*/
// ptr1 的资源所有权被转移到了 ptr2，ptr1 现在为空，无法访问资源。
// 转移所有权之后，原 unique_ptr 变为空，无法再使用该资源。
```

**`unique_ptr` 的自动释放资源**：当 `unique_ptr` 被销毁时，它会自动释放所管理的资源，避免了手动调用 `delete`，从而减少了内存泄漏的风险。

```c++
#include <iostream>
#include <memory>

class Test {
public:
    Test() { std::cout << "Test constructed\n"; }
    ~Test() { std::cout << "Test destructed\n"; }
};

int main() {
    {
        std::unique_ptr<Test> ptr = std::make_unique<Test>(); // ptr 构造时分配资源
    }  // ptr 离开作用域，自动释放资源
    return 0;
}
```

**`std::unique_ptr` 的优缺点**：

`std::unique_ptr` 是 C++11 引入的一个智能指针，属于“独占拥有”类型的智能指针。它表示对资源的唯一拥有权，确保在任何时刻只有一个 `unique_ptr` 指向某个资源。当 `unique_ptr` 被销毁时，它所管理的资源会被自动释放。因此，它非常适合用于管理动态分配的内存或其他需要自动清理的资源。

**`std::unique_ptr` 的基本特性**

1. **独占所有权**：每个 `unique_ptr` 都拥有它所指向的资源的唯一所有权。一个 `unique_ptr` 不允许被复制给另一个 `unique_ptr`，只能被移动。
2. **自动释放资源**：当 `unique_ptr` 超出作用域时，它会自动调用资源的析构函数来释放资源，避免了内存泄漏。
3. **不支持复制**：与 `shared_ptr` 不同，`unique_ptr` 不允许拷贝构造或拷贝赋值。它只能通过移动语义来转移所有权。
4. **轻量级**：`unique_ptr` 具有很低的开销，因为它没有引用计数等机制，仅通过析构函数来管理资源。

**`std::unique_ptr` 的用法**

**创建 `std::unique_ptr`**

`std::unique_ptr` 的创建通常使用 `std::make_unique`，这是推荐的方式。它不仅避免了手动使用 `new` 和 `delete`，还避免了在调用 `new` 时可能发生的内存泄漏问题。

```
cpp复制代码#include <iostream>
#include <memory>

class Test {
public:
    Test() { std::cout << "Test constructed\n"; }
    ~Test() { std::cout << "Test destructed\n"; }
};

int main() {
    // 使用 std::make_unique 创建 unique_ptr
    std::unique_ptr<Test> ptr = std::make_unique<Test>();
    return 0;
}
```

**推荐使用 `std::make_unique`**，而不是直接使用 `new` 来创建 `unique_ptr`。这样不仅更加简洁，还能避免不必要的内存分配错误。

**移动 `unique_ptr`**

`unique_ptr` 不支持复制操作，但它支持移动操作。通过 `std::move`，可以将一个 `unique_ptr` 的所有权从一个指针转移到另一个指针。这种转移是一次性的，即转移后原 `unique_ptr` 不再拥有资源。

```
cpp复制代码#include <iostream>
#include <memory>

class Test {
public:
    Test() { std::cout << "Test constructed\n"; }
    ~Test() { std::cout << "Test destructed\n"; }
};

int main() {
    std::unique_ptr<Test> ptr1 = std::make_unique<Test>();
    
    // 转移所有权
    std::unique_ptr<Test> ptr2 = std::move(ptr1);
    
    // ptr1 现在为空，不能再使用
    if (!ptr1) {
        std::cout << "ptr1 is empty\n";
    }

    return 0;
}
```

**输出**：

```
csharp复制代码Test constructed
ptr1 is empty
Test destructed
```

- `ptr1` 的资源所有权被转移到了 `ptr2`，`ptr1` 现在为空，无法访问资源。
- 转移所有权之后，原 `unique_ptr` 变为空，无法再使用该资源。

**`unique_ptr` 的自动释放资源**

当 `unique_ptr` 被销毁时，它会自动释放所管理的资源，避免了手动调用 `delete`，从而减少了内存泄漏的风险。

```
cpp复制代码#include <iostream>
#include <memory>

class Test {
public:
    Test() { std::cout << "Test constructed\n"; }
    ~Test() { std::cout << "Test destructed\n"; }
};

int main() {
    {
        std::unique_ptr<Test> ptr = std::make_unique<Test>(); // ptr 构造时分配资源
    }  // ptr 离开作用域，自动释放资源
    return 0;
}
```

**输出**：

```
复制代码Test constructed
Test destructed
```

- `ptr` 离开作用域时，资源自动被释放，调用了析构函数。

**`unique_ptr` 的数组管理**

`std::unique_ptr` 还可以用来管理动态分配的数组。为了区分数组和单一对象，`std::unique_ptr` 接受一个数组类型指针时，必须指定删除器 `[]`，以确保数组能够正确释放。

```
cpp复制代码#include <iostream>
#include <memory>

int main() {
    // 创建一个动态数组，并使用 unique_ptr 管理
    std::unique_ptr<int[]> arr = std::make_unique<int[]>(5);

    // 使用数组
    for (int i = 0; i < 5; ++i) {
        arr[i] = i * i;
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;

    // 当 arr 离开作用域时，内存自动释放
    return 0;
}
```

**输出**：

```
复制代码
0 1 4 9 16
```

- 这里使用 `std::unique_ptr<int[]>` 来管理一个动态数组。
- 当 `arr` 离开作用域时，数组会自动释放。

**`std::unique_ptr` 的优缺点**

**优点**：

* **自动管理资源**：`unique_ptr` 会在其生命周期结束时自动释放资源，避免了显式调用 `delete`，减少了内存泄漏的风险。
* **低开销**：`unique_ptr` 的实现简单且高效，内存开销较低，没有引用计数等机制。
* **强制独占所有权**：`unique_ptr` 强制执行资源的唯一所有权，使得设计更清晰，避免了资源的共享和多重所有权问题。
* **支持移动语义**：可以通过 `std::move` 将资源所有权从一个 `unique_ptr` 转移到另一个 `unique_ptr`，避免了拷贝的开销。

**缺点**：

* **不支持复制**：`unique_ptr` 不支持复制，只能进行转移操作。这在一些需要复制所有权的场景下可能不太方便。
* **无法共享所有权**：与 `std::shared_ptr` 不同，`unique_ptr` 不允许多个指针共享资源的所有权。若需要多个指针共享资源，必须使用 `shared_ptr`。
* **不能返回值**：如果你尝试将 `unique_ptr` 作为返回值，必须通过移动语义来返回，这在某些情况下可能使得代码变得复杂。

**总结**

`std::unique_ptr` 是 C++11 引入的非常重要的智能指针，旨在管理资源的唯一所有权。它通过自动释放资源来避免内存泄漏，是现代C++推荐使用的资源管理工具。`unique_ptr` 在大多数情况下具有较低的开销，使用起来简洁且安全，尤其适用于资源的独占管理场景。通过移动语义，`unique_ptr` 能够有效地转移资源所有权，但它不支持复制，这使得它非常适合管理无法共享的资源。

### 3.3`weak_ptr` 弱引用的智能指针

`std::weak_ptr` 是 C++11 引入的一种智能指针，主要用于 **解决 `std::shared_ptr` 的循环引用问题**，并 **提供一种非拥有型引用**，用于观察由 `std::shared_ptr` 管理的资源，更像是`sharead_ptr`的助手。

**`std::weak_ptr` 的基本特性**

**弱引用**

- `weak_ptr` **不参与引用计数**，不会增加 `std::shared_ptr` 的引用计数。
- `weak_ptr` 只是“观察”一个对象的存在，不会影响该对象的生命周期。

**解决循环引用**

- 在两个 `std::shared_ptr` 互相引用时，会导致引用计数无法归零，资源无法释放（循环引用）。
- 使用 `std::weak_ptr` 可以打破这种循环引用。

**临时访问资源**

- `weak_ptr` 不直接操作资源，需要通过 `lock()` 方法获取一个临时的 `std::shared_ptr`，然后进行访问。

**安全访问**

- 如果 `std::shared_ptr` 管理的资源已被释放，`std::weak_ptr` 可以检测到资源已不存在，防止野指针访问。

**`std::weak_ptr` 的常见用法**

`std::weak_ptr` 常与 `std::shared_ptr` 结合使用，用于检测和访问资源。

```c++
#include <iostream>
#include <memory>

class Test {
public:
    Test() { std::cout << "Test constructed\n"; }
    ~Test() { std::cout << "Test destructed\n"; }
};

int main() {
    std::shared_ptr<Test> sharedPtr = std::make_shared<Test>();
    std::weak_ptr<Test> weakPtr = sharedPtr; // weak_ptr 观察 sharedPtr 管理的对象

    std::cout << "Use count: " << sharedPtr.use_count() << std::endl; // 输出 1

    // 使用 lock 获取 shared_ptr，访问资源
    if (auto ptr = weakPtr.lock()) {
        std::cout << "Resource is still available.\n";
    } else {
        std::cout << "Resource has been released.\n";
    }

    sharedPtr.reset(); // 手动释放 shared_ptr 所管理的对象
    
    // 使用 expired() 判断 weak_ptr 所观察的资源是否仍然存在。
    if (weakPtr.expired()) {
    std::cout << "Resource has been released.\n";
	}

    // 再次检查 使用 lock() 获取一个临时的 std::shared_ptr，如果资源已不存在，则返回空指针。
    if (auto ptr = weakPtr.lock()) {
        std::cout << "Resource is still available.\n";
    } else {
        std::cout << "Resource has been released.\n";
    }

    return 0;
}
/*
Test constructed
Use count: 1
Resource is still available.
Resource has been released.
Resource has been released.
Test destructed
*/
```

 解决 `std::shared_ptr` 的循环引用

```c++
#include <iostream>
#include <memory>

class B;

class A {
public:
    std::weak_ptr<B> b_ptr;  // 使用 weak_ptr 打破循环引用
    ~A() { std::cout << "A destructed\n"; }
};

class B {
public:
    std::shared_ptr<A> a_ptr;
    ~B() { std::cout << "B destructed\n"; }
};

int main() {
    auto a = std::make_shared<A>();
    auto b = std::make_shared<B>();

    a->b_ptr = b;
    b->a_ptr = a;

    std::cout << "End of main()\n";
    return 0;
}
```

### 3.4 std::weak_ptr` vs `std::shared_ptr` vs `std::unique_ptr

| **特性**       | **std::shared_ptr** | **std::unique_ptr** | **std::weak_ptr**            |
| -------------- | ------------------- | ------------------- | ---------------------------- |
| **所有权**     | 共享拥有            | 独占拥有            | 无所有权，只能观察           |
| **引用计数**   | 支持引用计数        | 不支持引用计数      | 不影响引用计数               |
| **可拷贝**     | 支持拷贝与移动      | 仅支持移动          | 支持拷贝与移动               |
| **可移动**     | 支持                | 支持                | 支持                         |
| **循环引用**   | 可能发生循环引用    | 不存在循环引用      | 可避免循环引用               |
| **空指针检查** | 内置空指针检查      | 内置空指针检查      | 需要通过 `lock()` 检查       |
| **用途**       | 共享资源            | 独占资源            | 检测和临时访问资源           |
| **访问资源**   | 直接访问资源        | 直接访问资源        | 使用 `lock()` 获取资源       |
| **使用场景**   | 多个对象共享资源    | 单个对象独占资源    | 观察资源，不控制资源生命周期 |

### 3.5 总结

- `std::weak_ptr` 是一种非拥有型的智能指针，用于观察 `std::shared_ptr` 管理的资源。
- **核心作用**：解决 `std::shared_ptr` 的**循环引用问题**。
- **访问资源**：使用 `lock()` 临时获取一个 `std::shared_ptr`，或者使用 `expired()` 检测资源是否已经释放。
- 在现代 C++ 开发中，`std::weak_ptr` 是资源管理的关键工具，尤其在处理复杂的对象关系时，它可以有效避免内存泄漏。

**推荐用法**：

- 使用 `std::shared_ptr` 管理资源。
- 使用 `std::weak_ptr` 解决循环引用问题或监控资源的生命周期。

**牢记**：在资源共享的情况下，合理使用 `weak_ptr`，避免不必要的资源泄漏。

## 4. 使用C++11让多线程开发变得更简单

### 4.1 线程

C++11 引入了一套全新的 **多线程支持库**，使得多线程开发更加简单、安全和高效。与之前依赖第三方库（如 pthread）的时代不同，C++11 提供了标准的多线程 API，帮助开发者更轻松地进行多线程编程。

**创建线程**

使用 `std::thread` 可以轻松地创建一个新线程，只需要提供线程函数或者函数对象即可，并且可以同时指定线程函数的参数。

```c++
#include <iostream>
#include <thread>

void print_message(const std::string& message) {
   // 当前线程休眠3秒
    this_thread::sleep_for(std::chrono::second(3));
    std::cout << "Thread: " << message << std::endl;
}

int main() {
    std::thread t1(print_message, "Hello from thread!");// 持使用 Lambda 表达式创建线程

    // 等待线程结束
    t1.join();
    // 如果不希望线程被阻塞执行，可以调用detach()方法
    // t.detach();
    
	t1.get_id();//获取线程的ID

    return 0;
}

```

**多线程库核心组件**

| **组件**                  | **功能**                               |
| ------------------------- | -------------------------------------- |
| `std::thread`             | 创建和管理线程                         |
| `std::mutex`              | 互斥锁，防止线程竞争访问共享资源       |
| `std::lock_guard`         | 自动管理锁的生命周期，避免死锁         |
| `std::unique_lock`        | 更灵活的锁管理，支持条件变量           |
| `std::condition_variable` | 线程间的通信和同步                     |
| `std::future`             | 提供异步任务的返回值                   |
| `std::async`              | 异步执行任务，返回 `std::future`       |
| `std::promise`            | 用于向 `std::future` 传递结果          |
| `std::atomic`             | 原子操作，避免手动加锁，保证数据一致性 |

### 4.2 互斥量

**互斥量 (Mutex)** 是一种用于 **保护共享资源** 的同步原语，确保在 **多线程环境下** 对共享资源的访问是安全的。

在 C++11 中，`std::mutex` 提供了一个简单且高效的互斥锁机制，用于防止多个线程同时访问 **临界区**（Critical Section）。

C++11 提供的互斥量类型：

* std::mutex：独占的互斥量，不能递归使用，基础的互斥锁，提供基本的锁和解锁功能。
* std::timed_mutex：带超时的独占互斥量，不能递归使用，提供超时锁定功能（带超时的 `try_lock`）。
* std::recursive_mutex：递归互斥量，不带超时功能，允许同一个线程多次锁定同一个互斥锁。
* std::shared_mutex：允许多个线程同时进行读取，但只有一个线程进行写入。

#### 4.2.1 std::mutex

使用 `std::mutex` 可以保护共享资源，防止多个线程同时访问，从而避免 **数据竞争**（Race Condition）。

```c++
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx;  // 定义一个互斥量
int shared_counter = 0;  // 共享资源

void increment_counter() {
    for (int i = 0; i < 100000; ++i) {
        mtx.lock();  // 加锁
        ++shared_counter;  // 临界区
        mtx.unlock();  // 解锁
    }
}

int main() {
    std::thread t1(increment_counter);
    std::thread t2(increment_counter);

    t1.join();
    t2.join();

    std::cout << "Final Counter: " << shared_counter << std::endl;
    return 0;
}

```

#### 4.2.2 使用 `std::lock_guard` 自动管理锁

使用 `std::lock_guard` 可以避免手动调用 `lock()` 和 `unlock()`，更安全地管理互斥量。

```c++
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx;
int shared_counter = 0;

void increment_counter() {
    for (int i = 0; i < 100000; ++i) {
        std::lock_guard<std::mutex> lock(mtx);  // 自动加锁与解锁
        ++shared_counter;
    }
}

int main() {
    std::thread t1(increment_counter);
    std::thread t2(increment_counter);

    t1.join();
    t2.join();

    std::cout << "Final Counter: " << shared_counter << std::endl;
    return 0;
}
// 自动在作用域结束时解锁，避免死锁和忘记解锁的问题。
// 简化了代码逻辑，减少了出错的可能性。
```

`std::unique_lock`提供更灵活的锁管理，可以显式地加锁和解锁。

```c++
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx;

void print_message(const std::string& message) {
    std::unique_lock<std::mutex> lock(mtx);
    std::cout << message << std::endl;
    lock.unlock();  // 手动解锁
}

int main() {
    std::thread t1(print_message, "Hello from thread 1!");
    std::thread t2(print_message, "Hello from thread 2!");

    t1.join();
    t2.join();

    return 0;
}
```



#### 4.2.3 带超时的互斥量（`std::timed_mutex`）

`std::timed_mutex` 允许线程尝试在给定的时间内获取锁，如果超过指定时间则放弃锁定。

```c++
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>

std::timed_mutex tmtx;

void try_lock_for_example() {
    if (tmtx.try_lock_for(std::chrono::milliseconds(100))) {
        std::cout << "Thread " << std::this_thread::get_id() << " acquired the lock.\n";
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
        tmtx.unlock();
    } else {
        std::cout << "Thread " << std::this_thread::get_id() << " failed to acquire the lock.\n";
    }
}

int main() {
    std::thread t1(try_lock_for_example);
    std::thread t2(try_lock_for_example);

    t1.join();
    t2.join();

    return 0;
}
/*
Thread 1 acquired the lock.
Thread 2 failed to acquire the lock.
*/
```

#### 4.2.4 递归互斥量（`std::recursive_mutex`）

`std::recursive_mutex` 允许 **同一个线程** 多次锁定同一个互斥锁，常用于递归函数中。

```c++
#include <iostream>
#include <thread>
#include <mutex>

// 如果使用普通 std::mutex，将会导致 死锁，因为同一个线程不能多次获取同一个锁
std::recursive_mutex rmtx;

void recursive_function(int n) {
    if (n == 0) return;

    std::lock_guard<std::recursive_mutex> lock(rmtx);  // 自动管理锁
    std::cout << "Lock acquired at level " << n << "\n";

    recursive_function(n - 1);  // 递归调用
}

int main() {
    std::thread t1(recursive_function, 5);
    t1.join();

    return 0;
}
/*
Lock acquired at level 5
Lock acquired at level 4
Lock acquired at level 3
Lock acquired at level 2
Lock acquired at level 1
*/
```

#### 4.2.5 共享互斥量（`std::shared_mutex`）

**读写锁**：`std::shared_mutex` 允许多个线程 **并发读取** 共享资源，但只有一个线程可以 **写入**。

```c++
#include <iostream>
#include <thread>
#include <shared_mutex>
#include <chrono>

std::shared_mutex smtx;
int shared_value = 0;

void reader() {
    std::shared_lock<std::shared_mutex> lock(smtx);  // 读锁
    std::cout << "Reader Thread: " << shared_value << std::endl;
}

void writer() {
    std::unique_lock<std::shared_mutex> lock(smtx);  // 写锁
    ++shared_value;
    std::cout << "Writer Thread updated value to: " << shared_value << std::endl;
}

int main() {
    std::thread t1(reader);
    std::thread t2(writer);
    std::thread t3(reader);

    t1.join();
    t2.join();
    t3.join();

    return 0;
}
/*
Reader Thread: 0
Writer Thread updated value to: 1
Reader Thread: 1
*/
```

#### 4.2.6 死锁问题与避免

```c++
#include <iostream>
#include <thread>
#include <mutex>

std::mutex m1, m2;

void func1() {
    std::lock_guard<std::mutex> lock1(m1);
    std::lock_guard<std::mutex> lock2(m2);
    std::cout << "Function 1\n";
}

void func2() {
    std::lock_guard<std::mutex> lock2(m2);
    std::lock_guard<std::mutex> lock1(m1);
    std::cout << "Function 2\n";
}

int main() {
    std::thread t1(func1);
    std::thread t2(func2);

    t1.join();
    t2.join();

    return 0;
}
// 解决方案：使用 std::lock
std::lock(m1, m2);  // 同时锁定多个互斥量，避免死锁
std::lock_guard<std::mutex> lock1(m1, std::adopt_lock);
std::lock_guard<std::mutex> lock2(m2, std::adopt_lock);

```

### 4.3 条件变量

在 C++11 中，**条件变量**（`std::condition_variable`）是一个用于 **线程间通信** 和 **同步** 的机制。它允许一个线程在某个条件满足之前进入等待状态，另一个线程在条件满足时通知它继续执行。条件变量需要和互斥量配合起来使用。这种机制常见于 **生产者-消费者问题** 等场景。

**条件变量** 允许一个线程等待某个 **条件成立**，而不需要持续占用 CPU 资源。通过条件变量，线程可以在等待期间被 **挂起**，而不是不断轮询检查条件（避免忙等待）。当条件满足时，其他线程可以通过 **`notify_one`** 或 **`notify_all`** 唤醒等待的线程。

**条件变量相关组件**

| **组件**                  | **功能**                                     |
| ------------------------- | -------------------------------------------- |
| `std::condition_variable` | 条件变量类，用于线程间的条件等待和通知。     |
| `std::unique_lock`        | 灵活的互斥锁管理，用于配合条件变量使用。     |
| `wait`                    | 使线程进入等待状态，直到被唤醒或条件满足。   |
| `notify_one`              | 唤醒一个正在等待条件的线程。                 |
| `notify_all`              | 唤醒所有正在等待条件的线程。                 |
| `wait_for`                | 等待一段时间后超时返回。                     |
| `wait_until`              | 等待到某个特定时间点，如果条件不满足则返回。 |

**场景**：使用条件变量实现 **生产者-消费者模型**。

```c++
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>

std::mutex mtx; // 互斥锁
std::condition_variable cv; // 条件变量
std::queue<int> buffer; // 共享缓冲区
const unsigned int MAX_BUFFER_SIZE = 5; // 缓冲区最大容量

bool done = false; // 控制生产者状态

// 生产者线程
void producer() {
    for (int i = 0; i < 10; ++i) {
        std::unique_lock<std::mutex> lock(mtx); // 加锁
        cv.wait(lock, [] { return buffer.size() < MAX_BUFFER_SIZE; }); // 等待缓冲区有空间

        buffer.push(i);
        std::cout << "Produced: " << i << std::endl;

        cv.notify_one(); // 通知消费者
    }
    done = true;
    cv.notify_all(); // 通知所有等待的消费者线程
}

// 消费者线程
void consumer() {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx); // 加锁
        cv.wait(lock, [] { return !buffer.empty() || done; }); // 等待缓冲区有数据或生产者完成

        if (!buffer.empty()) {
            int item = buffer.front();
            buffer.pop();
            std::cout << "Consumed: " << item << std::endl;
        } else if (done) {
            break; // 生产者完成，消费者退出
        }
    }
}

int main() {
    std::thread producer_thread(producer);
    std::thread consumer_thread(consumer);

    producer_thread.join();
    consumer_thread.join();

    return 0;
}
```

#### 4.3.1 notify_one` 与 `notify_all

**`notify_one`**：唤醒一个等待的线程。

**`notify_all`**：唤醒所有等待的线程。

如果多个线程等待相同的条件变量：

- **`notify_one`**：通常唤醒一个线程，避免“惊群效应”（所有线程都被唤醒，只有一个线程能成功获取资源）。
- **`notify_all`**：适用于所有等待的线程都应该被唤醒的情况。

#### 4.3.2 wait_for

`wait_for` 允许线程等待指定时间，如果在时间内没有满足条件，就返回。

```c++
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <chrono>

std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void worker() {
    std::unique_lock<std::mutex> lock(mtx);
    if (cv.wait_for(lock, std::chrono::seconds(2), [] { return ready; })) {
        std::cout << "Worker thread finished its job." << std::endl;
    } else {
        std::cout << "Worker thread timeout!" << std::endl;
    }
}

int main() {
    std::thread t(worker);

    std::this_thread::sleep_for(std::chrono::seconds(1));
    ready = true;
    cv.notify_one();

    t.join();
    return 0;
}
```

#### 4.3.3 wait_until

`wait_until` 允许线程等待到某个特定时间点。

```c++
std::unique_lock<std::mutex> lock(mtx);
if (cv.wait_until(lock, std::chrono::system_clock::now() + std::chrono::seconds(5), [] { return ready; })) {
    std::cout << "Condition met!" << std::endl;
} else {
    std::cout << "Timeout occurred!" << std::endl;
}
```

### 4.4 原子变量

在 C++11 中，**原子变量（Atomic Variables）** 是一种 **多线程环境下安全访问的共享变量**。C++11 引入了 `<atomic>` 头文件，为多线程编程提供了**原子操作支持**，可以在不使用互斥锁（`std::mutex`）的情况下，安全地进行 **数据访问** 和 **操作**。

> **原子性**：原子变量是 **不可分割** 的操作单元，多个线程对原子变量的访问不会发生 **数据竞争**（Race Condition）。
>
> **线程安全**：多线程访问同一个原子变量时，不需要显式加锁，减少了 **锁开销** 和 **死锁风险**。
>
> **高效**：原子变量使用 **CPU 提供的底层原子指令**，避免了上下文切换带来的性能开销。
>
> **适合简单数据类型**：主要用于 **整数**、**布尔值** 和 **指针** 等简单类型。

原子变量的声明与使用

```c++
#include <atomic>
std::atomic<int> counter(0);  // 声明一个原子整数
std::atomic<bool> flag(false);  // 声明一个原子布尔值
std::atomic<void*> ptr(nullptr);  // 声明一个原子指针

```

 常见操作

| **操作**                  | **描述**                   |
| ------------------------- | -------------------------- |
| `store(value)`            | 将一个值存储到原子变量中。 |
| `load()`                  | 从原子变量中读取值。       |
| `exchange(value)`         | 交换原子变量的值。         |
| `compare_exchange_strong` | 比较并交换（强保证）。     |
| `compare_exchange_weak`   | 比较并交换（弱保证）。     |
| `fetch_add(value)`        | 原子地加上一个值。         |
| `fetch_sub(value)`        | 原子地减去一个值。         |

线程安全的计数器

```c++
#include <iostream>
#include <thread>
#include <atomic>

std::atomic<int> counter(0);  // 原子计数器

void increment() {
    for (int i = 0; i < 10000; ++i) {
        counter.fetch_add(1);  // 原子加操作
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);

    t1.join();
    t2.join();

    std::cout << "Final counter value: " << counter.load() << std::endl;
    return 0;
}
```

### 4.5 异步操作类

C++11提供了异步操作相关的类，主要有std::future 、std::promise、std::package_task、std::async等工具。

异步操作核心组件

| **组件**             | **功能**                                    |
| -------------------- | ------------------------------------------- |
| `std::async`         | 异步执行一个任务，返回 `std::future` 对象。 |
| `std::future`        | 用于存储异步任务的结果。                    |
| `std::promise`       | 提供一个异步任务的结果的写入端。            |
| `std::packaged_task` | 将可调用对象包装成一个异步任务。            |

#### 4.5.1 `std::async`：异步任务

`std::async` 用于 **启动异步任务**，并返回一个 **`std::future`** 对象。

`std::future` 用于获取异步任务的结果。

```c++
#include <iostream>
#include <future>

int compute_sum(int a, int b) {
    return a + b;
}

int main() {
    // 启动异步任务
    std::future<int> result = std::async(std::launch::async, compute_sum, 10, 20);

    // 获取结果
    std::cout << "Result: " << result.get() << std::endl;

    return 0;
}
// Result: 30
```

**`std::launch` 策略**

- **`std::launch::async`**：强制异步执行任务。
- **`std::launch::deferred`**：延迟执行，只有在调用 `get()` 或 `wait()` 时才执行。
- **`std::launch::async | std::launch::deferred`**：由系统决定异步或延迟执行。

#### 4.5.2 `std::future`：异步结果

`std::future` 用于 **存储异步任务的结果**。

可以通过 `get()` 获取结果（阻塞调用，直到任务完成）。

可以使用 `wait()` 等待任务完成。

| **函数**     | **功能**                 |
| ------------ | ------------------------ |
| `get()`      | 获取异步任务的结果。     |
| `wait()`     | 等待异步任务完成。       |
| `wait_for`   | 等待指定的时间。         |
| `wait_until` | 等待到特定的时间点。     |
| `valid()`    | 检查 `future` 是否有效。 |

```c++
#include <iostream>
#include <future>
#include <thread>
#include <chrono>

int slow_task() {
    std::this_thread::sleep_for(std::chrono::seconds(2));
    return 42;
}

int main() {
    std::future<int> result = std::async(std::launch::async, slow_task);

    std::cout << "Waiting for the result..." << std::endl;
    result.wait();  // 等待任务完成

    std::cout << "Result: " << result.get() << std::endl;
    return 0;
}
```

#### 4.5.3 `std::promise`：结果提供者

`std::promise` 提供一个 **可写入的异步结果接口**。

通过 `std::promise` 生成 `std::future`，用来传递数据到异步任务。

```c++
#include <iostream>
#include <thread>
#include <future>

void set_value(std::promise<int>&& promise) {
    std::this_thread::sleep_for(std::chrono::seconds(2));
    promise.set_value(42);  // 设置结果
}

int main() {
    std::promise<int> promise;
    std::future<int> result = promise.get_future();  // 获取 future

    std::thread t(set_value, std::move(promise));

    std::cout << "Waiting for result..." << std::endl;
    std::cout << "Result: " << result.get() << std::endl;

    t.join();
    return 0;
}
// std::promise 将结果传递给 std::future。
// std::future 可以在主线程中获取结果。
```

#### 4.5.4 `std::packaged_task`：包装任务

`std::packaged_task` 将 **可调用对象**（函数、Lambda）打包成一个异步任务。

可以通过 `std::future` 获取异步结果。

```c++
#include <iostream>
#include <future>
#include <thread>

int task_function(int a, int b) {
    return a + b;
}

int main() {
    std::packaged_task<int(int, int)> task(task_function);
    std::future<int> result = task.get_future();

    std::thread t(std::move(task), 10, 20);
    t.join();

    std::cout << "Result: " << result.get() << std::endl;
    return 0;
}

```

